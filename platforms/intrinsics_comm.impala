type COMM_COMM = &();
type COMM_Datatype = int;
type COMM_Op = &();
type COMM_REQUEST = &();
type COMM_STATUS = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];

extern "C" {
    fn anydsl_comm_init() -> i32;
    fn anydsl_comm_initialized(&mut i32) -> i32;
    fn anydsl_comm_size(COMM_COMM, &mut i32) -> i32;
    fn anydsl_comm_rank(COMM_COMM, &mut i32) -> i32;
    fn anydsl_comm_allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_COMM) -> i32;
    fn anydsl_comm_send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_COMM) -> i32;
    fn anydsl_comm_recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn anydsl_comm_irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_REQUEST) -> i32;
    fn anydsl_comm_wait(COMM_REQUEST, COMM_STATUS) -> i32;
    fn anydsl_comm_probe(i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn anydsl_comm_get_count(COMM_STATUS, COMM_Datatype, &mut i32) -> i32;
    fn anydsl_comm_gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32;
    fn anydsl_comm_allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_COMM) -> i32;
    fn anydsl_comm_barrier(COMM_COMM) -> i32;
    fn anydsl_comm_wtime() -> f64;
    fn anydsl_comm_finalize() -> i32;
    fn anydsl_comm_finalized(&mut i32) -> i32;
    // wrappers for getting constants
    fn anydsl_comm_get_world() -> COMM_COMM;
    fn anydsl_comm_get_int() -> COMM_Datatype;
    fn anydsl_comm_get_double() -> COMM_Datatype;
    fn anydsl_comm_get_char() -> COMM_Datatype;
    fn anydsl_comm_get_byte() -> COMM_Datatype;
    fn anydsl_comm_get_max() -> COMM_Op;
    fn anydsl_comm_get_sum() -> COMM_Op;
    fn anydsl_comm_get_status_ignore() -> COMM_STATUS;
    fn exit(int) -> ();
}

struct MPIComms {
    world : COMM_COMM,
}

struct MPIOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct MPIStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct MPIStatuses {
    ignore : &mut MPIStatus,
}

struct Communicator {
    comms : MPIComms,
    ops : MPIOps,
    status : MPIStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    char_t: COMM_Datatype,
    byte_t: COMM_Datatype,

    init : fn() -> (i32 /* size */, i32 /* rank */),                            //DONE
    size : fn() -> i32,                                                         //DONE
    rank : fn() -> i32,                                                         //DONE
    send : fn(COMM_Buf, i32, COMM_Datatype, i32, i32) -> (),                    //DONE
    recv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32) -> (),                 //DONE
    irecv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32) -> COMM_REQUEST,      //DONE
    wait : fn(COMM_REQUEST) -> (),                                              //DONE
    probe: fn(i32, i32) -> &mut MPIStatus,                                      //DONE
    get_count: fn(&mut MPIStatus, COMM_Datatype) -> i32,                        //DONE
    gather: fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, i32) -> (),           //DONE
    allgather: fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype) -> (),             //DONE
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op) -> (),   //DONE
    barrier : fn() -> (),                                                       //DONE
    wtime : fn() -> f64,                                                        //DONE
    finalize : fn() -> (),                                                      //DONE
}

fn anydsl_comm_create_request() -> COMM_REQUEST {
    &()
}

fn anydsl_comm_check_status(status: int) -> () {
    if(status!=0) {
        print_string("Received invalid status from MPI!");
        exit(255);
    }
}

fn @comm() -> Communicator {
    Communicator {
        comms : MPIComms {
            world : anydsl_comm_get_world(),
        },
        ops : MPIOps {
            max : anydsl_comm_get_max(),
            sum : anydsl_comm_get_sum(),
        },
        status : MPIStatuses {
            ignore : anydsl_comm_get_status_ignore() as &mut MPIStatus,
        },
        double_t : anydsl_comm_get_double(),
        int_t : anydsl_comm_get_int(),
        char_t: anydsl_comm_get_char(),
        byte_t: anydsl_comm_get_byte(),

        init : @|| {
            //trick allows two call init multiple times
            let mut initialized = 0;
            anydsl_comm_initialized(&mut initialized);
            if(initialized == 0) {
                anydsl_comm_check_status(anydsl_comm_init());
            }
            let mut size : i32;
            let mut rank : i32;
            anydsl_comm_check_status(anydsl_comm_size(anydsl_comm_get_world(),&mut size));
            anydsl_comm_check_status(anydsl_comm_rank(anydsl_comm_get_world(),&mut rank));
            (size,rank)
        },
        size : @|| {
            let mut numNodes : i32;
            anydsl_comm_check_status(anydsl_comm_size(anydsl_comm_get_world(),&mut numNodes));
            numNodes
        },
        rank : @|| {
            let mut rank : i32;
            anydsl_comm_check_status(anydsl_comm_rank(anydsl_comm_get_world(),&mut rank));
            rank
        },
        send : @|buf, count, datatype, dest, tag| {
            anydsl_comm_check_status(anydsl_comm_send(buf, count, datatype, dest, tag, anydsl_comm_get_world()));
        },
        recv : @|buf, count, datatype, source, tag| {
            let mut status : MPIStatus;
            anydsl_comm_check_status(anydsl_comm_recv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut status as COMM_STATUS));
        },
        irecv : @|buf, count, datatype, source, tag| {
            let mut request : i32;
            anydsl_comm_check_status(anydsl_comm_irecv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut request as COMM_REQUEST));
            &mut request as COMM_REQUEST
        },
        wait : @|request| {
            let mut status: MPIStatus;
            anydsl_comm_check_status(anydsl_comm_wait(request, &mut status as COMM_STATUS));
        },
        probe: @|source, tag| {
            let mut status : MPIStatus;
            anydsl_comm_check_status(anydsl_comm_probe(source, tag, anydsl_comm_get_world(), &mut status as COMM_STATUS));
            &mut status
        },
        get_count: @|status, datatype| {
            let mut count : i32;
            anydsl_comm_check_status(anydsl_comm_get_count(status as COMM_STATUS, datatype, &mut count));
            count
        },
        gather: @|sendbuf, recvbuf, count_per_node, datatype, root| {
            anydsl_comm_check_status(anydsl_comm_gather(sendbuf, count_per_node, datatype, recvbuf, count_per_node, datatype, root, anydsl_comm_get_world()));
        },
        allgather: @|sendbuf, recvbuf, count_per_node, datatype| {
            anydsl_comm_check_status(anydsl_comm_allgather(sendbuf, count_per_node, datatype, recvbuf, count_per_node, datatype, anydsl_comm_get_world()));
        },
        allreduce : @|sendbuf, recvbuf, count_per_node, datatype, op| {
            anydsl_comm_check_status(anydsl_comm_allreduce(sendbuf, recvbuf, count_per_node, datatype, op, anydsl_comm_get_world()));
        },
        barrier : @|| {
            anydsl_comm_check_status(anydsl_comm_barrier(anydsl_comm_get_world()));
        },
        wtime : anydsl_comm_wtime,
        finalize : @|| {
            //trick allows to call finalize multiple times
            let mut finalized = 0;
            anydsl_comm_finalized(&mut finalized);
            if(finalized == 0) {
                anydsl_comm_check_status(anydsl_comm_finalize());
            }
        }
    }
};
