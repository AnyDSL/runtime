type COMM_COMM = &();
type COMM_Datatype = int;
type COMM_Op = &();
type COMM_REQUEST = &();
type COMM_STATUS = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];

extern "C" {
    fn anydsl_comm_init() -> i32;
    fn anydsl_comm_initialized(&mut i32) -> i32;
    fn anydsl_comm_size(COMM_COMM, &mut i32) -> i32;
    fn anydsl_comm_rank(COMM_COMM, &mut i32) -> i32;
    fn anydsl_comm_allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_COMM) -> i32;
    fn anydsl_comm_send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_COMM) -> i32;
    fn anydsl_comm_recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn anydsl_comm_irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_REQUEST) -> i32;
    fn anydsl_comm_wait(COMM_REQUEST, COMM_STATUS) -> i32;
    fn anydsl_comm_probe(i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn anydsl_comm_get_count(COMM_STATUS, COMM_Datatype, &mut i32) -> i32;
    fn anydsl_comm_gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32;
    fn anydsl_comm_allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_COMM) -> i32;
    fn anydsl_comm_barrier(COMM_COMM) -> i32;
    fn anydsl_comm_wtime() -> f64;
    fn anydsl_comm_finalize() -> i32;
    fn anydsl_comm_finalized(&mut i32) -> i32;
    // wrappers for getting constants
    fn anydsl_comm_get_world() -> COMM_COMM;
    fn anydsl_comm_get_int() -> COMM_Datatype;
    fn anydsl_comm_get_double() -> COMM_Datatype;
    fn anydsl_comm_get_char() -> COMM_Datatype;
    fn anydsl_comm_get_byte() -> COMM_Datatype;
    fn anydsl_comm_get_max() -> COMM_Op;
    fn anydsl_comm_get_sum() -> COMM_Op;
    fn anydsl_comm_get_status_ignore() -> COMM_STATUS;
    fn exit(int) -> ();
}

struct MPIComms {
    world : COMM_COMM,
}

struct MPIOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct MPIStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct MPIStatuses {
    ignore : &mut MPIStatus,
}

struct Communicator {
    comms : MPIComms,
    ops : MPIOps,
    status : MPIStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    char_t: COMM_Datatype,
    byte_t: COMM_Datatype,

    //first parameter: &int for number of Nodes, second parameter: &int for current rank
    init : fn() -> (i32 /* number of nodes */, i32 /* current rank */),
    initWithoutVars: fn() -> (),
    size : fn() -> i32,
    rank : fn() -> i32,
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Op) -> (),
    send : fn(COMM_Buf, i32, i32, i32) -> (),
    recv : fn(COMM_MutBuf, i32, i32, i32) -> MPIStatus,
    irecv : fn(COMM_MutBuf, i32, i32, i32) -> COMM_REQUEST,
    wait : fn(COMM_REQUEST) -> MPIStatus,
    probe: fn(i32, i32) -> MPIStatus,
    get_count: fn(&mut MPIStatus, COMM_Datatype) -> i32,
    gather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32) -> (),
    allgather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype) -> (),
    barrier : fn() -> (),
    wtime : fn() -> f64,
    finalize : fn() -> ()
}

fn anydsl_comm_create_request() -> COMM_REQUEST {
    &()
}

fn anydsl_comm_check_status(status: int) -> () {
    if(status!=0) {
        print_string("Received invalid status from MPI!");
        exit(255);
    }
}

extern fn start_COMM() -> () {
    //trick allows two call init multiple times
    let mut initialized = 0;
    let mut status = 0;
    anydsl_comm_initialized(&mut initialized);
    if(initialized == 0) {
        status = anydsl_comm_init();
    }
    anydsl_comm_check_status(status);
}

fn @comm() -> Communicator {
    Communicator {
        comms : MPIComms {
            world : anydsl_comm_get_world(),
        },
        ops : MPIOps {
            max : anydsl_comm_get_max(),
            sum : anydsl_comm_get_sum(),
        },
        status : MPIStatuses {
            ignore : anydsl_comm_get_status_ignore() as &mut MPIStatus,
        },
        double_t : anydsl_comm_get_double(),
        int_t : anydsl_comm_get_int(),
        char_t: anydsl_comm_get_char(),
        byte_t: anydsl_comm_get_byte(),

        init : @|| {
            start_COMM();
            let mut numNodes = 0;
            let mut rank = 0;
            anydsl_comm_check_status(anydsl_comm_size(anydsl_comm_get_world(),&mut numNodes));
            anydsl_comm_check_status(anydsl_comm_rank(anydsl_comm_get_world(),&mut rank));
            (numNodes, rank)
        },
        initWithoutVars: || {
            start_COMM();
        },
        size : @|| {
            let mut numNodes = -1;
            anydsl_comm_check_status(anydsl_comm_size(anydsl_comm_get_world(),&mut numNodes));
            numNodes
        },
        rank : @|| {
            let mut rank = -1;
            anydsl_comm_check_status(anydsl_comm_rank(anydsl_comm_get_world(),&mut rank));
            rank
        },
        allreduce : @|sendbuf, recvbuf, count, op| {
            let mut datatype = 0;
            mpi_type(&sendbuf, &mut datatype);
            anydsl_comm_check_status(anydsl_comm_allreduce(sendbuf, recvbuf, count, datatype, op, anydsl_comm_get_world()));
        },
        send : @|buf, count, dest, tag| {
            let mut datatype = 0;
            mpi_type(buf, &mut datatype);
            anydsl_comm_check_status(anydsl_comm_send(buf, count, datatype, dest, tag, anydsl_comm_get_world()));
        },
        recv : @|buf, count, source, tag| {
            let mut datatype = 0;
            let mut status : MPIStatus;
            mpi_type(buf, &mut datatype);
            anydsl_comm_check_status(anydsl_comm_recv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut status as COMM_STATUS));
            status
        },
        irecv : @|buf, count, source, tag| {
            let mut datatype = 0;
            let request = anydsl_comm_create_request();
            mpi_type(buf, &mut datatype);
            anydsl_comm_check_status(anydsl_comm_irecv(buf, count, datatype, source, tag, anydsl_comm_get_world(), request));
            request
        },
        wait : @|request| {
            let mut status : MPIStatus;
            anydsl_comm_check_status(anydsl_comm_wait(request, &mut status as COMM_STATUS));
            status
        },
        probe: @|source, tag| {
            let mut status : MPIStatus;
            anydsl_comm_check_status(anydsl_comm_probe(source, tag, anydsl_comm_get_world(), &mut status as COMM_STATUS));
            status
        },
        get_count: @|status, datatype| {
            let mut count = 0;
            anydsl_comm_check_status(anydsl_comm_get_count(status as COMM_STATUS, datatype, &mut count));
            count
        },
        gather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root| {
            anydsl_comm_check_status(anydsl_comm_gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, anydsl_comm_get_world()));
        },
        allgather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype| {
            anydsl_comm_check_status(anydsl_comm_allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, anydsl_comm_get_world()));
        },
        barrier : @|| {
            anydsl_comm_check_status(anydsl_comm_barrier(anydsl_comm_get_world()));
        },
        wtime : anydsl_comm_wtime,
        finalize : @|| {
            //trick allows to call finalize multiple times
            let mut finalized = 0;
            anydsl_comm_check_status(anydsl_comm_finalized(&mut finalized));
            if(finalized == 0) {
                anydsl_comm_check_status(anydsl_comm_finalize());
            }
        }
    }
};
