
type size_t = u64;

type COMM_Comm = &();
type COMM_Datatype = &int;
type COMM_Op = &();
type COMM_Request = &();
type COMM_Status = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];

extern "C" {
    fn anydsl_comm_init() -> i32;
    fn anydsl_comm_initialized(&mut i32) -> i32;
    fn anydsl_comm_size(COMM_Comm, &mut i32) -> i32;
    fn anydsl_comm_rank(COMM_Comm, &mut i32) -> i32;
    fn anydsl_comm_allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_Comm) -> i32;
    fn anydsl_comm_send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_Comm) -> i32;
    fn anydsl_comm_recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, COMM_Status) -> i32;
    fn anydsl_comm_irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, &COMM_Request) -> i32;
    fn anydsl_comm_wait(&COMM_Request, COMM_Status) -> i32;
    fn anydsl_comm_probe(i32, i32, COMM_Comm, COMM_Status) -> i32;
    fn anydsl_comm_get_count(i32, i32, COMM_Datatype, &mut i32, COMM_Comm) -> i32;
    fn anydsl_comm_gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_Comm) -> i32;
    fn anydsl_comm_allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_Comm) -> i32;
    fn anydsl_comm_barrier(COMM_Comm) -> i32;
    fn anydsl_comm_wtime() -> f64;
    fn anydsl_comm_finalize() -> i32;
    fn anydsl_comm_finalized(&mut i32) -> i32;
    // wrappers for getting constants
    fn anydsl_comm_get_world() -> COMM_Comm;
    fn anydsl_comm_get_int() -> COMM_Datatype;
    fn anydsl_comm_get_double() -> COMM_Datatype;
    fn anydsl_comm_get_char() -> COMM_Datatype;
    fn anydsl_comm_get_byte() -> COMM_Datatype;
    fn anydsl_comm_get_max() -> COMM_Op;
    fn anydsl_comm_get_sum() -> COMM_Op;
    fn anydsl_comm_get_status_ignore() -> COMM_Status;
    fn exit(int) -> ();
}

struct COMMComms {
    world : COMM_Comm,
}

struct COMMOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct COMMStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct COMMStatuses {
    ignore : &mut COMMStatus,
}

struct Communicator {
    comms : COMMComms,
    ops : COMMOps,
    status : COMMStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    init : fn() -> (i32,i32),
    size : fn() -> i32,
    rank : fn() -> i32,
    send : fn(COMM_Buf, i32, COMM_Datatype, i32, i32) -> (),
    recv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32) -> (),
    irecv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32) -> COMM_Request,
    wait : fn(COMM_Request) -> (),
    get_count: fn(i32, i32, COMM_Datatype) -> i32,
    gather: fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, i32) -> (),
    allgather: fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype) -> (),
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op) -> (),
    barrier : fn() -> (),
    wtime : fn() -> f64,
    finalize : fn() -> (),
}

fn @comm() -> Communicator {
    Communicator {
        comms : COMMComms {
            world : anydsl_comm_get_world(),
        },
        ops : COMMOps {
            max : anydsl_comm_get_max(),
            sum : anydsl_comm_get_sum(),
        },
        status : COMMStatuses {
            ignore : anydsl_comm_get_status_ignore() as &mut COMMStatus,
        },
        double_t : anydsl_comm_get_double(),
        int_t : anydsl_comm_get_int(),
        init : @|| {
            //check if already started
            let mut initialized : i32;
            check_status(anydsl_comm_initialized(&mut initialized));
            if(initialized == 0) {
                check_status(anydsl_comm_init());
            }
            let mut size : i32;
            let mut rank : i32;
            check_status(anydsl_comm_size(anydsl_comm_get_world(), &mut size));
            check_status(anydsl_comm_rank(anydsl_comm_get_world(), &mut rank));
            (size,rank)
        },
        size : @|| {
            let mut size : i32;
            check_status(anydsl_comm_size(anydsl_comm_get_world(), &mut size));
            size
        },
        rank : @|| {
            let mut rank : i32;
            check_status(anydsl_comm_rank(anydsl_comm_get_world(), &mut rank));
            rank
        },
        send : @|buf, count, datatype, dest, tag| {
            check_status(anydsl_comm_send(buf, count, datatype, dest, tag, anydsl_comm_get_world()));
        },
        recv : @|buf, count, datatype, source, tag| {
            let mut status : COMMStatus;
            check_status(anydsl_comm_recv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut status as COMM_Status));
        },
        irecv : @|buf, count, datatype, source, tag| {
            let mut tmp : i32;
            let mut request : COMM_Request = &mut tmp as COMM_Request;
            check_status(anydsl_comm_irecv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut request));
            request
        },
        wait : @|request| {
            let mut status : COMMStatus;
            check_status(anydsl_comm_wait(&request, &mut status as COMM_Status));
        },
        get_count: @|source, tag, datatype| {
            let mut count : i32;
            check_status(anydsl_comm_get_count(source, tag, datatype, &mut count, anydsl_comm_get_world()));
            count
        },
        gather: @|sendbuf, recvbuf, count_per_node, datatype, root| {
            check_status(anydsl_comm_gather(sendbuf, count_per_node, datatype, recvbuf, count_per_node, datatype, root, anydsl_comm_get_world()));
        },
        allgather: @|sendbuf, recvbuf, count_per_node, datatype| {
            check_status(anydsl_comm_allgather(sendbuf, count_per_node, datatype, recvbuf, count_per_node, datatype, anydsl_comm_get_world()));
        },
        allreduce : @|sendbuf, recvbuf, count_per_node, datatype, op| {
            check_status(anydsl_comm_allreduce(sendbuf, recvbuf, count_per_node, datatype, op, anydsl_comm_get_world()));
        },
        barrier : @|| {
            check_status(anydsl_comm_barrier(anydsl_comm_get_world()));
        },
        wtime : anydsl_comm_wtime,
        finalize : @|| {
            //check if already finalized
            let mut finalized : i32;
            check_status(anydsl_comm_finalized(&mut finalized));
            if(finalized == 0) {
                check_status(anydsl_comm_finalize());
            }
        },
    }
}
;

fn check_status(status: i32) -> () {
    if(status!=0) {
        print_string("Received invalid status from MPI!");
        exit(255);
    }
}
