
type size_t = u64;

type COMM_Comm = &();
type COMM_Datatype = &int;
type COMM_Op = &();
type COMM_Request = &();
type COMM_Status = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];

extern "C" {
    fn anydsl_comm_init() -> i32;
    fn anydsl_comm_initialized(&mut i32) -> i32;
    fn anydsl_comm_size(COMM_Comm, &mut i32) -> i32;
    fn anydsl_comm_rank(COMM_Comm, &mut i32) -> i32;
    fn anydsl_comm_allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_Comm) -> i32;
    fn anydsl_comm_send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_Comm) -> i32;
    fn anydsl_comm_recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, COMM_Status) -> i32;
    fn anydsl_comm_irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, &COMM_Request) -> i32;
    fn anydsl_comm_wait(&COMM_Request, COMM_Status) -> i32;
    fn anydsl_comm_probe(i32, i32, COMM_Comm, COMM_Status) -> i32;
    fn anydsl_comm_get_count(i32, i32, COMM_Datatype, &mut i32, COMM_Comm) -> i32;
    fn anydsl_comm_gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_Comm) -> i32;
    fn anydsl_comm_allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_Comm) -> i32;
    fn anydsl_comm_barrier(COMM_Comm) -> i32;
    fn anydsl_comm_bcast(COMM_MutBuf, i32, COMM_Datatype, i32, COMM_Comm) -> i32;
    fn anydsl_comm_wtime() -> f64;
    fn anydsl_comm_finalize() -> i32;
    fn anydsl_comm_finalized(&mut i32) -> i32;
    // wrappers for getting constants
    fn anydsl_comm_get_world() -> COMM_Comm;
    fn anydsl_comm_get_int() -> COMM_Datatype;
    fn anydsl_comm_get_double() -> COMM_Datatype;
    fn anydsl_comm_get_char() -> COMM_Datatype;
    fn anydsl_comm_get_byte() -> COMM_Datatype;
    fn anydsl_comm_get_max() -> COMM_Op;
    fn anydsl_comm_get_sum() -> COMM_Op;
    fn anydsl_comm_get_status_ignore() -> COMM_Status;
    fn exit(int) -> ();
    fn get_num_threads() -> int;
}

struct COMMComms {
    world : COMM_Comm,
}

struct COMMOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct COMMStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct COMMStatuses {
    ignore : &mut COMMStatus,
}

struct Communicator {
    comms : COMMComms,
    ops : COMMOps,
    status : COMMStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    char_t: COMM_Datatype,
    byte_t: COMM_Datatype,
    parallel_reduction_buffer: Buffer,
    init : fn() -> (i32,i32),
    size : fn() -> i32,
    rank : fn() -> i32,
    send : fn(COMM_Buf, i32, COMM_Datatype, i32, i32) -> (),
    recv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32) -> (),
    irecv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32) -> COMM_Request,
    wait : fn(COMM_Request) -> (),
    get_count: fn(i32, i32, COMM_Datatype) -> i32,
    gather: fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, i32) -> (),
    allgather: fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype) -> (),
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op) -> (),
    broadcast: fn(COMM_MutBuf, i32, COMM_Datatype, i32) -> (),
    barrier : fn() -> (),
    wtime : fn() -> f64,
    finalize : fn() -> (),
    parallel_reduction: fn(Buffer, &mut [f64], &mut [f64], int, fn(double, double) -> double) -> double,
}

fn @comm() -> Communicator {
    Communicator {
        comms : COMMComms {
            world : anydsl_comm_get_world(),
        },
        ops : COMMOps {
            max : anydsl_comm_get_max(),
            sum : anydsl_comm_get_sum(),
        },
        status : COMMStatuses {
            ignore : anydsl_comm_get_status_ignore() as &mut COMMStatus,
        },
        int_t : anydsl_comm_get_int(),
        double_t : anydsl_comm_get_double(),
        char_t: anydsl_comm_get_char(),
        byte_t: anydsl_comm_get_byte(),
        parallel_reduction_buffer: alloc_cpu(get_num_threads() * sizeof[double]()),
        init : @|| {
            //check if already started
            let mut initialized : i32;
            anydsl_comm_check_status(anydsl_comm_initialized(&mut initialized));
            if(initialized == 0) {
                anydsl_comm_check_status(anydsl_comm_init());
            }
            let mut size : i32;
            let mut rank : i32;
            anydsl_comm_check_status(anydsl_comm_size(anydsl_comm_get_world(), &mut size));
            anydsl_comm_check_status(anydsl_comm_rank(anydsl_comm_get_world(), &mut rank));
            (size,rank)
        },
        size : @|| {
            let mut size : i32;
            anydsl_comm_check_status(anydsl_comm_size(anydsl_comm_get_world(), &mut size));
            size
        },
        rank : @|| {
            let mut rank : i32;
            anydsl_comm_check_status(anydsl_comm_rank(anydsl_comm_get_world(), &mut rank));
            rank
        },
        send : @|buf, count, datatype, dest, tag| {
            anydsl_comm_check_status(anydsl_comm_send(buf, count, datatype, dest, tag, anydsl_comm_get_world()));
        },
        recv : @|buf, count, datatype, source, tag| {
            let mut status : COMMStatus;
            anydsl_comm_check_status(anydsl_comm_recv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut status as COMM_Status));
        },
        irecv : @|buf, count, datatype, source, tag| {
            let mut tmp : i32;
            let mut request : COMM_Request = &mut tmp as COMM_Request;
            anydsl_comm_check_status(anydsl_comm_irecv(buf, count, datatype, source, tag, anydsl_comm_get_world(), &mut request));
            request
        },
        wait : @|request| {
            let mut status : COMMStatus;
            anydsl_comm_check_status(anydsl_comm_wait(&request, &mut status as COMM_Status));
        },
        get_count: @|source, tag, datatype| {
            let mut count : i32;
            anydsl_comm_check_status(anydsl_comm_get_count(source, tag, datatype, &mut count, anydsl_comm_get_world()));
            count
        },
        gather: @|sendbuf, recvbuf, count_per_node, datatype, root| {
            anydsl_comm_check_status(anydsl_comm_gather(sendbuf, count_per_node, datatype, recvbuf, count_per_node, datatype, root, anydsl_comm_get_world()));
        },
        allgather: @|sendbuf, recvbuf, count_per_node, datatype| {
            anydsl_comm_check_status(anydsl_comm_allgather(sendbuf, count_per_node, datatype, recvbuf, count_per_node, datatype, anydsl_comm_get_world()));
        },
        allreduce: @|sendbuf, recvbuf, count_per_node, datatype, op| {
            anydsl_comm_check_status(anydsl_comm_allreduce(sendbuf, recvbuf, count_per_node, datatype, op, anydsl_comm_get_world()));
        },
        broadcast: @|buf, count, datatype, root| {
            anydsl_comm_bcast(buf, count, datatype, root, anydsl_comm_get_world());
        },
        barrier: @|| {
            anydsl_comm_check_status(anydsl_comm_barrier(anydsl_comm_get_world()));
        },
        wtime: anydsl_comm_wtime,
        finalize : @|| {
            //check if already finalized
            let mut finalized : i32;
            anydsl_comm_check_status(anydsl_comm_finalized(&mut finalized));
            if(finalized == 0) {
                anydsl_comm_check_status(anydsl_comm_finalize());
            }
        },
        parallel_reduction: @|buffer, v1, v2, localNumEntries, operator| {
            let mut num_threads = get_num_threads();
            if(num_threads > localNumEntries) {
                num_threads = localNumEntries;
            }
            let num_thread_entries = localNumEntries / num_threads;
            let parallel_reduction_buffer = bitcast[&mut[double]](buffer.data);

            for curThreadIndex in parallel(num_threads, 0, num_threads) {

                let mut temp = 0.0;
                for curIndex in range(curThreadIndex * num_thread_entries, anydsl_comm_min(localNumEntries, (curThreadIndex + 1) * num_thread_entries)) {
                    temp += operator(v1(curIndex),v2(curIndex));
                }
                parallel_reduction_buffer(curThreadIndex) = temp;
            }

            let mut result = 0.0;
            for i in range(0, num_threads) {
                result += parallel_reduction_buffer(i);
            }

            result
        }
    }
}
;

fn @anydsl_comm_min(a: int, b: int) -> int {
    if(a < b) {
        a
    }
    else {
        b
    }
}

fn anydsl_comm_check_status(status: i32) -> () {
    if(status!=0) {
        print_string("Received invalid status from MPI!");
        exit(255);
    }
}
