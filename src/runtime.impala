extern "C" {
    fn "anydsl_info" runtime_info() -> ();

    fn "anydsl_alloc"          runtime_alloc(i32, i64) -> &[i8];
    fn "anydsl_alloc_host"     runtime_alloc_host(i32, i64) -> &[i8];
    fn "anydsl_alloc_unified"  runtime_alloc_unified(i32, i64) -> &[i8];
    fn "anydsl_copy"           runtime_copy(i32, &[i8], i64, i32, &[i8], i64, i64) -> ();
    fn "anydsl_get_device_ptr" runtime_get_device_ptr(i32, &[i8]) -> &[i8];
    fn "anydsl_release"        runtime_release(i32, &[i8]) -> ();
    fn "anydsl_release_host"   runtime_release_host(i32, &[i8]) -> ();
    fn "anydsl_synchronize"    runtime_synchronize(i32) -> ();

    fn "anydsl_random_seed"     random_seed(u32) -> ();
    fn "anydsl_random_val_f32"  random_val_f32() -> f32;
    fn "anydsl_random_val_u64"  random_val_u64() -> u64;

    fn "anydsl_get_micro_time"  get_micro_time() -> i64;
    fn "anydsl_get_kernel_time" get_kernel_time() -> i64;

    fn "anydsl_print_i16"    print_i16(i16) -> ();
    fn "anydsl_print_i32"    print_i32(i32) -> ();
    fn "anydsl_print_i64"    print_i64(i64) -> ();
    fn "anydsl_print_f32"    print_f32(f32) -> ();
    fn "anydsl_print_f64"    print_f64(f64) -> ();
    fn "anydsl_print_char"   print_char(u8) -> ();
    fn "anydsl_print_string" print_string(&[u8]) -> ();
    fn "anydsl_print_flush"  print_flush() -> ();
}

struct Buffer {
    data : &[i8],
    size : i64,
    device : i32
}

fn @alloc(dev: i32, size: i32) -> Buffer {
    Buffer {
        device : dev,
        data : runtime_alloc(dev, size as i64),
        size : size as i64
    }
}
fn @alloc_host(dev: i32, size: i32) -> Buffer {
    Buffer {
        device : dev,
        data : runtime_alloc_host(dev, size as i64),
        size : size as i64
    }
}
fn @alloc_unified(dev: i32, size: i32) -> Buffer {
    Buffer {
        device : dev,
        data : runtime_alloc_unified(dev, size as i64),
        size : size as i64
    }
}
fn @release(buf: Buffer) -> () { runtime_release(buf.device, buf.data) }

fn @runtime_device(platform: i32, device: i32) -> i32 { platform | (device << 4) }

fn @alloc_cpu(size: i32) -> Buffer { alloc(0, size) }
fn @alloc_cuda(dev: i32, size: i32) -> Buffer { alloc(runtime_device(1, dev), size) }
fn @alloc_cuda_host(dev: i32, size: i32) -> Buffer { alloc_host(runtime_device(1, dev), size) }
fn @alloc_cuda_unified(dev: i32, size: i32) -> Buffer { alloc_unified(runtime_device(1, dev), size) }
fn @synchronize_cuda(dev: i32) -> () { runtime_synchronize(runtime_device(1, dev)) }
fn @alloc_opencl(dev: i32, size: i32) -> Buffer { alloc(runtime_device(2, dev), size) }
fn @alloc_opencl_unified(dev: i32, size: i32) -> Buffer { alloc_unified(runtime_device(2, dev), size) }
fn @synchronize_opencl(dev: i32) -> () { runtime_synchronize(runtime_device(2, dev)) }
fn @alloc_hsa(dev: i32, size: i32) -> Buffer { alloc(runtime_device(3, dev), size) }
fn @alloc_hsa_host(dev: i32, size: i32) -> Buffer { alloc_host(runtime_device(3, dev), size) }
fn @alloc_hsa_unified(dev: i32, size: i32) -> Buffer { alloc_unified(runtime_device(3, dev), size) }
fn @synchronize_hsa(dev: i32) -> () { runtime_synchronize(runtime_device(3, dev)) }

fn @copy(src: Buffer, dst: Buffer) -> () {
    runtime_copy(src.device, src.data, 0i64, dst.device, dst.data, 0i64, src.size)
}

fn @copy_offset(src: Buffer, off_src: i32, dst: Buffer, off_dst: i32, size: i32) -> () {
    runtime_copy(src.device, src.data, off_src as i64, dst.device, dst.data, off_dst as i64, size as i64)
}


// range, range_step, unroll, unroll_step, etc.
fn @(?lower & ?upper & ?step) may_unroll_step(lower: i32, upper: i32, @step: i32, body: fn(i32) -> ()) -> () {
    if lower < upper {
        @@body(lower);
        may_unroll_step(lower+step, upper, step, body)
    }
}

fn @(?upper & ?lower & ?step) may_unroll_step_rev(upper: i32, lower: i32, @step: i32, body: fn(i32) -> ()) -> () {
    if upper > lower {
        @@body(upper);
        may_unroll_step_rev(upper-step, lower, step, body)
    }
}

fn @range(lower: i32, upper: i32, body: fn(i32) -> ()) -> () { may_unroll_step($lower, $upper, 1, body) }
fn @range_step(lower: i32, upper: i32, step: i32, body: fn(i32) -> ()) -> () { may_unroll_step($lower, $upper, step, body) }
fn @range_rev(upper: i32, lower: i32, body: fn(i32) -> ()) -> () { may_unroll_step_rev($upper, $lower, 1, body) }

fn @unroll(lower: i32, upper: i32, body: fn(i32) -> ()) -> () { may_unroll_step(lower, upper, 1, body) }
fn @unroll_step(lower: i32, upper: i32, step: i32, body: fn(i32) -> ()) -> () { may_unroll_step(lower, upper, step, body) }
fn @unroll_rev(upper: i32, lower: i32, body: fn(i32) -> ()) -> () { may_unroll_step_rev(upper, lower, 1, body) }

//COMMUNICATOR

type COMM_COMM = &();
type COMM_Datatype = int;
type COMM_Op = &();
type COMM_REQUEST = &();
type COMM_STATUS = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];

extern "C" {
    fn anydsl_comm_init() -> i32;
    fn anydsl_comm_initialized(&mut i32) -> i32;
    fn MPI_Comm_size(COMM_COMM, &mut i32) -> i32;
    fn MPI_Comm_rank(COMM_COMM, &mut i32) -> i32;
    fn MPI_Allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_COMM) -> i32;
    fn MPI_Send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_COMM) -> i32;
    fn MPI_Recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn MPI_Irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_REQUEST) -> i32;
    fn MPI_Wait(COMM_REQUEST, COMM_STATUS) -> i32;
    fn MPI_Probe(i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn MPI_Get_count(COMM_STATUS, COMM_Datatype, &mut i32) -> i32;
    fn MPI_Gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32;
    fn MPI_Allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_COMM) -> i32;
    fn MPI_Barrier(COMM_COMM) -> i32;
    fn MPI_Wtime() -> f64;
    fn MPI_Finalize() -> i32;
    fn MPI_Finalized(&mut i32) -> i32;
    // wrappers in mpi.cpp for getting MPI constants
    fn anydsl_comm_get_world() -> COMM_COMM;
    fn anydsl_comm_get_int() -> COMM_Datatype;
    fn anydsl_comm_get_double() -> COMM_Datatype;
    fn anydsl_comm_get_char() -> COMM_Datatype;
    fn anydsl_comm_get_byte() -> COMM_Datatype;
    fn get_mpi_max() -> COMM_Op;
    fn get_mpi_sum() -> COMM_Op;
    fn get_mpi_status_ignore() -> COMM_STATUS;
}

struct MPIComms {
    world : COMM_COMM,
}

struct MPIOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct MPIStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct MPIStatuses {
    ignore : &mut MPIStatus,
}

struct Communicator {
    comms : MPIComms,
    ops : MPIOps,
    status : MPIStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    char_t: COMM_Datatype,
    byte_t: COMM_Datatype,

    //first parameter: &int for number of Nodes, second parameter: &int for current rank
    init : fn(&mut i32, &mut i32) -> i32,
    initWithoutVars: fn() -> i32,
    comm_size : fn(&mut i32) -> i32,
    comm_rank : fn(&mut i32) -> i32,
    get_cur_rank: fn() -> i32,
    get_number_of_nodes: fn() -> i32,
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op) -> i32,
    send : fn(COMM_Buf, i32, COMM_Datatype, i32, i32) -> i32,
    recv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, &mut MPIStatus) -> i32,
    irecv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_REQUEST) -> i32,
    wait : fn(COMM_REQUEST, &mut MPIStatus) -> i32,
    probe: fn(i32, i32, &mut MPIStatus) -> i32,
    get_count: fn(&mut MPIStatus, COMM_Datatype, &mut i32) -> i32,
    gather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32) -> i32,
    allgather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype) -> i32,
    barrier : fn() -> i32,
    wtime : fn() -> f64,
    finalize : fn() -> i32,
    create_request: fn() -> COMM_REQUEST
}

extern fn start_COMM() -> i32 {
    //trick allows two call init multiple times
    let mut initialized = 0;
    let mut status = 0;
    anydsl_comm_initialized(&mut initialized);
    if(initialized == 0) {
        status = anydsl_comm_init();
    }
    status
}

fn @comm() -> Communicator {
    Communicator {
        comms : MPIComms {
            world : anydsl_comm_get_world(),
        },
        ops : MPIOps {
            max : get_mpi_max(),
            sum : get_mpi_sum(),
        },
        status : MPIStatuses {
            ignore : get_mpi_status_ignore() as &mut MPIStatus,
        },
        double_t : anydsl_comm_get_double(),
        int_t : anydsl_comm_get_int(),
        char_t: anydsl_comm_get_char(),
        byte_t: anydsl_comm_get_byte(),

        init : @|numNodes,rank| {
            let status = start_COMM();
            MPI_Comm_size(anydsl_comm_get_world(),numNodes);
            MPI_Comm_rank(anydsl_comm_get_world(),rank);
            status
        },
        initWithoutVars: || {
            start_COMM()
        },
        comm_size : @|numNodes| {
            MPI_Comm_size(anydsl_comm_get_world(),numNodes)
        },
        comm_rank : @|rank| {
            MPI_Comm_rank(anydsl_comm_get_world(),rank)
        },
        get_cur_rank: @|| {
            let mut curRank = -1;
            MPI_Comm_rank(anydsl_comm_get_world(),&mut curRank);
            curRank
        },
        get_number_of_nodes: @|| {
            let mut numNodes = -1;
            MPI_Comm_size(anydsl_comm_get_world(),&mut numNodes);
            numNodes
        },
        allreduce : @|sendbuf, recvbuf, count, datatype, op| {
            MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, anydsl_comm_get_world())
        },
        send : @|buf, count, datatype, dest, tag| {
            MPI_Send(buf, count, datatype, dest, tag, anydsl_comm_get_world())
        },
        recv : @|buf, count, datatype, source, tag, status| {
            MPI_Recv(buf, count, datatype, source, tag, anydsl_comm_get_world(), status as COMM_STATUS)
        },
        irecv : @|buf, count, datatype, source, tag, request| {
            MPI_Irecv(buf, count, datatype, source, tag, anydsl_comm_get_world(), request)
        },
        wait : @|request, status| {
            MPI_Wait(request, status as COMM_STATUS)
        },
        probe: @|source, tag, status| {
            MPI_Probe(source, tag, anydsl_comm_get_world(), status as COMM_STATUS)
        },
        get_count: @|status, datatype, count| {
            MPI_Get_count(status as COMM_STATUS, datatype, count)
        },
        gather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root| {
            MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, anydsl_comm_get_world())
        },
        allgather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype| {
            MPI_Allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, anydsl_comm_get_world())
        },
        barrier : @|| {
            MPI_Barrier(anydsl_comm_get_world())
        },
        wtime : MPI_Wtime,
        finalize : @|| {
            //trick allows to call finalize multiple times
            let mut finalized = 0;
            MPI_Finalized(&mut finalized);
            if(finalized == 0) {
                MPI_Finalize()
            }
            else {
                0
            }
        },
        create_request: @|| {
            &()
        }
    }
};
